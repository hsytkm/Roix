<#@ template debug="false" hostspecific="false" language="C#" linePragmas="false" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY UnitGenerator. DO NOT CHANGE IT.
// </auto-generated>
#nullable enable
using System;
<# if (!string.IsNullOrEmpty(Namespace)) { #>
namespace <#= Namespace #>
<# } #>
{
    readonly partial struct <#= Name #> : IEquatable<<#= Name #>>, IFormattable
    {
        private readonly SourceValues _values;

<# foreach (var prop in Properties) { #>
        public <#= prop.Type #> <#= prop.Name #> => this._values.<#= prop.Name #>;
<# } #>

<# if (!IsConstructorDeclared) { #>
        public <#= Name #>(<#= GetTypeAndLowerNamesForArgs("{0} {1}") #>)
        {
            this._values = new(<#= GetLowerNames() #>);
  <# if (HasFlag(RoixStructGeneratorOptions.Validate)) { #> 
            this.Validate(this);
  <# } #>
        }
<# } #>
<# if (HasFlag(RoixStructGeneratorOptions.Validate)) { #>
        // RoixStructGeneratorOptions.Validate
        private partial void Validate(in <#= Name #> value);
<# } #>
        public void Deconstruct(<#= GetTypeAndLowerNames("out {0} {1}") #>) => (<#= GetLowerNames() #>) = (<#= GetNames() #>);

        public bool Equals(<#= Name #> other) => this == other;
        public override bool Equals(object? obj) => (obj is <#= Name #> other) && Equals(other);
        public override int GetHashCode() => HashCode.Combine(<#= GetNames() #>);
        public static bool operator ==(in <#= Name #> left, in <#= Name #> right) => (<#= GetNames("left.{0}") #>) == (<#= GetNames("right.{0}") #>);
        public static bool operator !=(in <#= Name #> left, in <#= Name #> right) => !(left == right);

        public override string ToString() => $"<#= Name #> {{ <#= GetToString() #> }}";
        public string ToString(string? format, IFormatProvider? formatProvider) => $"<#= Name #> {{ <#= GetToStringWithFormat() #> }}";

        public static <#= Name #> Zero { get; } = default;
        public bool IsZero => this == Zero;
        public bool IsNotZero => !this.IsZero;
<# if (HasFlag(RoixStructGeneratorOptions.Rect)) { #>
        // RoixStructGeneratorOptions.Rect
        public <#= GetRoixDefaultBuiltInType() #> X => Location.X;
        public <#= GetRoixDefaultBuiltInType() #> Y => Location.Y;
        public <#= GetRoixDefaultBuiltInType() #> Width => Size.Width;
        public <#= GetRoixDefaultBuiltInType() #> Height => Size.Height;
        public <#= GetRoixDefaultBuiltInType() #> Left => Location.X;
        public <#= GetRoixDefaultBuiltInType() #> Right => Location.X + Size.Width;
        public <#= GetRoixDefaultBuiltInType() #> Top => Location.Y;
        public <#= GetRoixDefaultBuiltInType() #> Bottom => Location.Y + Size.Height;
        public <#= GetRoixPointStructName() #> TopLeft => Location;
        public <#= GetRoixPointStructName() #> TopRight => new(Right, Top);
        public <#= GetRoixPointStructName() #> BottomLeft => new(Left, Bottom);
        public <#= GetRoixPointStructName() #> BottomRight => new(Right, Bottom);

        public bool IsInside(in <#= GetRoixSizeStructName() #> border) => 0 <= Left && Right <= border.Width && 0 <= Top && Bottom <= border.Height;
        public bool IsOutside(in <#= GetRoixSizeStructName() #> border) => !IsInside(border);

        /// <summary>
        /// Roi の左上点を優先して Rect を border サイズに収めます。
        /// Roi の左上点が Border の境界上に乗っている場合は、戻り値の Size が Zero になります。
        /// </summary>
        private <#= Name #> GetClippedBorderRectByPointPriority(in <#= GetRoixSizeStructName() #> border)
        {
            if (IsInside(border)) return this;

            var left = Math.Clamp(this.Left, 0, border.Width);
            var top = Math.Clamp(this.Top, 0, border.Height);

            // 最小側にめり込んで制限された場合は正数になる（その値だけ長さを伸縮する）
            var (deltaLeft, deltaTop) = (left - this.Left, top - this.Top);

            var width = Math.Clamp(this.Width - deltaLeft, 0, border.Width - left);
            var height = Math.Clamp(this.Height - deltaTop, 0, border.Height - top);
            return new(new <#= GetRoixPointStructName() #>(left, top), new <#= GetRoixSizeStructName() #>(width, height));
        }

        /// <summary>
        /// Roi のサイズを優先して Rect を border サイズに収めます。
        /// </summary>
        private <#= Name #> GetClippedBorderRectBySizePriority(in <#= GetRoixSizeStructName() #> border)
        {
            if (IsInside(border)) return this;

            var width = Math.Clamp(this.Width, 0, border.Width);
            var height = Math.Clamp(this.Height, 0, border.Height);
            var left = Math.Clamp(this.Left - GetJutLength(this.Left, this.Right, 0, border.Width), 0, border.Width - width);
            var top = Math.Clamp(this.Top - GetJutLength(this.Top, this.Bottom, 0, border.Height), 0, border.Height - height);
            return new(new <#= GetRoixPointStructName() #>(left, top), new <#= GetRoixSizeStructName() #>(width, height));

            static double GetJutLength(double left, double right, double min, double max)
            {
                // 水平方向の場合、左に食み出てたら負数、右に食み出てたら正数を返します
                if (left < min) return min - left;
                if (max < right) return right - max;
                return 0;
            }
        }
<# } #>
<# if (HasFlag(RoixStructGeneratorOptions.XYPair)) { #>
        // RoixStructGeneratorOptions.XYPair
        public bool IsIncludeZero => (X == 0 || Y == 0);
        public bool IsIncludeNegative => (X < 0 || Y < 0);
        public bool IsInside(in <#= GetRoixSizeStructName() #> border) => (0 <= X && X <= border.Width) && (0 <= Y && Y <= border.Height);
        public bool IsOutside(in <#= GetRoixSizeStructName() #> border) => !IsInside(border);
<# } #>
<# if (HasFlag(RoixStructGeneratorOptions.WithBorder)) { #>
        // RoixStructGeneratorOptions.WithBorder
        public bool IsInsideBorder => this.Value.IsInside(this.Border);
        public bool IsOutsideBorder => !this.IsInsideBorder;

        public <#= Name #> ConvertToNewBorder(in <#= GetRoixSizeStructName() #> newBorder)
        {
            if (this.Border.IsEmpty || this.Border.IsZero) return this;
            if (newBorder.IsEmpty) throw new ArgumentException(ExceptionMessages.SizeIsEmpty);
            if (newBorder.IsZero) throw new ArgumentException(ExceptionMessages.SizeIsZero);

            return new(this.Value * (newBorder / this.Border), newBorder);
        }
  <# if (HasFlag(RoixStructGeneratorOptions.TypeInt)) { #>
        public <#= GetRoixNameWithoutInt() #> ConvertToNewBorder(in RoixSize newBorder)
        {
            if (this.Border.IsEmpty || this.Border.IsZero) return this;
            if (newBorder.IsEmpty) throw new ArgumentException(ExceptionMessages.SizeIsEmpty);
            if (newBorder.IsZero) throw new ArgumentException(ExceptionMessages.SizeIsZero);

            return new(this.Value * (newBorder / this.Border), newBorder);
        }
  <# } #>

<# } #>
<# if (HasFlag(RoixStructGeneratorOptions.ArithmeticOperator1)) { #>
        // RoixStructGeneratorOptions.ArithmeticOperator1
        public static <#= Name #> operator +(in <#= Name #> value1, in <#= Name #> value2)
        {
            return new(<#= GetOperate2Value(ArithmeticOperators.Add, "value1", "value2") #>);
        }

        public static <#= Name #> operator -(in <#= Name #> value1, in <#= Name #> value2)
        {
            return new(<#= GetOperate2Value(ArithmeticOperators.Subtract, "value1", "value2") #>);
        }
<# } #>
<# if (HasFlag(RoixStructGeneratorOptions.ArithmeticOperator2)) { #>
        // RoixStructGeneratorOptions.ArithmeticOperator2
        public static <#= Name #> operator *(in <#= Name #> value, double scalar)
        {
            return new(<#= GetOperate1Value(ArithmeticOperators.Multiply, "value", "scalar") #>);
        }

        public static <#= Name #> operator /(in <#= Name #> value, double scalar)
        {
            if (scalar == 0) throw new DivideByZeroException();
            return new(<#= GetOperate1Value(ArithmeticOperators.Divide, "value", "scalar") #>);
        }

        public static <#= Name #> operator *(in <#= Name #> value, in RoixRatioXY ratio)
        {
            return new(<#= GetOperatorRoixAndRatio(ArithmeticOperators.Multiply, "value", "ratio") #>);
        }

        public static <#= Name #> operator /(in <#= Name #> value, in RoixRatioXY ratio)
        {
            if (ratio.IsIncludeZero) throw new DivideByZeroException();
            return new(<#= GetOperatorRoixAndRatio(ArithmeticOperators.Divide, "value", "ratio") #>);
        }

        public static RoixRatioXY operator /(in <#= Name #> value1, in <#= Name #> value2)
        {
            if (value2.IsIncludeZero) throw new DivideByZeroException();
            return new(<#= GetOperate2Value(ArithmeticOperators.Divide, "value1", "value2") #>);
        }
<# } #>

    }
}
