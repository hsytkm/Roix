<#@ template debug="false" hostspecific="false" language="C#" linePragmas="false" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY UnitGenerator. DO NOT CHANGE IT.
// </auto-generated>
#nullable enable
using System;

<#
    string GetProperties(System.Collections.Generic.IEnumerable<string> items, string format = "")
    {
        if (!string.IsNullOrWhiteSpace(format))
            return string.Join(", ", items.Select(x => string.Format(format, x)));

        return string.Join(", ", items);
    }

    string GetNames(string format = "")
    {
        return GetProperties(Properties.Select(p => p.Name), format);
    }

    string GetLowerNames(string format = "")
    {
        return GetProperties(Properties.Select(p => p.Name.ToLower()), format);
    }
    
    string GetInTypeIfNecessary(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax typeSyntax)
    {
        var type = typeSyntax.ToString();
        switch (type)
        {
            case "int":
            case "double":
                return type;
            default:
                return "in " + type;
        }
    }

    string GetTypeAndLowerNames(string format = "")
    {
        if (!string.IsNullOrWhiteSpace(format))
            return string.Join(", ", Properties.Select(p => string.Format(format, p.Type, p.Name.ToLower())));

        return string.Join(", ", Properties.Select(p => GetInTypeIfNecessary(p.Type) + " " + p.Name.ToLower()));
    }

    string GetToString()
    {
        return string.Join(", ", Properties.Select(p => p.Name + " = {" + p.Name + "}"));
    }
    
    string GetToStringWithFormat()
    {
        return string.Join(", ", Properties.Select(p => p.Name + " = {" + p.Name + ".ToString(format, formatProvider)}"));
    }
    
    string GetRoixSizeStructName()
    {
        return HasFlag(RoixStructGeneratorOptions.TypeInt) ? "RoixIntSize" : "RoixSize";
    }
    
    string GetRoixPointStructName()
    {
        return HasFlag(RoixStructGeneratorOptions.TypeInt) ? "RoixIntPoint" : "RoixPoint";
    }
    
    string GetRoixBuiltInType()
    {
        return HasFlag(RoixStructGeneratorOptions.TypeInt) ? "int" : "double";
    }
    
    string GetRoixNameWithoutInt()
    {
        return HasFlag(RoixStructGeneratorOptions.TypeInt) ? Name.Replace("Int", "") : Name;
    }

    string GetOperatorString(ArithmeticOperators ope)
    {
        if (ope == ArithmeticOperators.Add) return " + ";
        if (ope == ArithmeticOperators.Subtract) return " - ";
        if (ope == ArithmeticOperators.Multiply) return " * ";
        if (ope == ArithmeticOperators.Divide) return " / ";
        return "";
    }

    string GetOperate2Value(ArithmeticOperators ope, string name1, string name2)
    {
        var os = GetOperatorString(ope);
        return string.Join(", ", Properties.Select(p => name1 + "." + p.Name + os + name2 + "." + p.Name));
    }

    string GetRatioProperty(int index)
    {
        return ((index & 1) == 0) ? "X" : "Y";
    }
    
    string GetOperatorRoixAndRatio(ArithmeticOperators ope, string name1, string name2)
    {
        var os = GetOperatorString(ope);
        var roixs = Properties.Select(p => name1 + "." + p.Name).ToArray();

        var opes = new string[roixs.Length];
        for (int i = 0; i < roixs.Length; ++i)
        {
            opes[i] = roixs[i] + os + (name2 + "." + GetRatioProperty(i));
        }
        return string.Join(", ", opes);
    }
    
    string GetOperate1Value(ArithmeticOperators ope, string name1, string value2)
    {
        var os = GetOperatorString(ope);
        return string.Join(", ", Properties.Select(p => name1 + "." + p.Name + os + value2));
    }
    
#>

<# if (!string.IsNullOrEmpty(Namespace)) { #>
namespace <#= Namespace #>
<# } #>
{
    readonly partial struct <#= Name #> : IEquatable<<#= Name #>>, IFormattable
    {
        private readonly SourceValues _values;

<# foreach (var prop in Properties) { #>
        public <#= prop.Type #> <#= prop.Name #> => this._values.<#= prop.Name #>;
<# } #>

<# if (!IsConstructorDeclared) { #>
        public <#= Name #>(<#= GetTypeAndLowerNames() #>)
        {
            this._values = new(<#= GetLowerNames() #>);
  <# if (HasFlag(RoixStructGeneratorOptions.Validate)) { #> 
            this.Validate(this);
  <# } #>
        }
<# } #>
<# if (HasFlag(RoixStructGeneratorOptions.Validate)) { #>
        // RoixStructGeneratorOptions.Validate
        private partial void Validate(in <#= Name #> value);
<# } #>
        public void Deconstruct(<#= GetTypeAndLowerNames("out {0} {1}") #>) => (<#= GetLowerNames() #>) = (<#= GetNames() #>);

        public bool Equals(<#= Name #> other) => this == other;
        public override bool Equals(object? obj) => (obj is <#= Name #> other) && Equals(other);
        public override int GetHashCode() => HashCode.Combine(<#= GetNames() #>);
        public static bool operator ==(in <#= Name #> left, in <#= Name #> right) => (<#= GetNames("left.{0}") #>) == (<#= GetNames("right.{0}") #>);
        public static bool operator !=(in <#= Name #> left, in <#= Name #> right) => !(left == right);

        public override string ToString() => $"<#= Name #> {{ <#= GetToString() #> }}";
        public string ToString(string? format, IFormatProvider? formatProvider) => $"<#= Name #> {{ <#= GetToStringWithFormat() #> }}";

        public static <#= Name #> Zero { get; } = default;
        public bool IsZero => this == Zero;
        public bool IsNotZero => !this.IsZero;
<# if (HasFlag(RoixStructGeneratorOptions.Rect)) { #>
        // RoixStructGeneratorOptions.Rect
        public <#= GetRoixBuiltInType() #> X => Location.X;
        public <#= GetRoixBuiltInType() #> Y => Location.Y;
        public <#= GetRoixBuiltInType() #> Width => Size.Width;
        public <#= GetRoixBuiltInType() #> Height => Size.Height;
        public <#= GetRoixBuiltInType() #> Left => Location.X;
        public <#= GetRoixBuiltInType() #> Right => Location.X + Size.Width;
        public <#= GetRoixBuiltInType() #> Top => Location.Y;
        public <#= GetRoixBuiltInType() #> Bottom => Location.Y + Size.Height;
        public <#= GetRoixPointStructName() #> TopLeft => Location;
        public <#= GetRoixPointStructName() #> TopRight => new(Right, Top);
        public <#= GetRoixPointStructName() #> BottomLeft => new(Left, Bottom);
        public <#= GetRoixPointStructName() #> BottomRight => new(Right, Bottom);

        public bool IsInside(in <#= GetRoixSizeStructName() #> border) => 0 <= Left && Right <= border.Width && 0 <= Top && Bottom <= border.Height;
        public bool IsOutside(in <#= GetRoixSizeStructName() #> border) => !IsInside(border);
<# } #>
<# if (HasFlag(RoixStructGeneratorOptions.XYPair)) { #>
        // RoixStructGeneratorOptions.XYPair
        public bool IsIncludeZero => (X == 0 || Y == 0);
        public bool IsInside(in <#= GetRoixSizeStructName() #> border) => (0 <= X && X <= border.Width) && (0 <= Y && Y <= border.Height);
        public bool IsOutside(in <#= GetRoixSizeStructName() #> border) => !IsInside(border);
<# } #>
<# if (HasFlag(RoixStructGeneratorOptions.WithBorder)) { #>
        // RoixStructGeneratorOptions.WithBorder
        public bool IsInsideBorder => this.Value.IsInside(this.Border);
        public bool IsOutsideBorder => !this.IsInsideBorder;

        public <#= Name #> ConvertToNewBorder(in <#= GetRoixSizeStructName() #> newBorder)
        {
            if (this.Border.IsEmpty || this.Border.IsZero) return this;
            if (newBorder.IsEmpty) throw new ArgumentException(ExceptionMessages.SizeIsEmpty);
            if (newBorder.IsZero) throw new ArgumentException(ExceptionMessages.SizeIsZero);

            return new(this.Value * (newBorder / this.Border), newBorder);
        }
  <# if (HasFlag(RoixStructGeneratorOptions.TypeInt)) { #>
        public <#= GetRoixNameWithoutInt() #> ConvertToNewBorder(in RoixSize newBorder)
        {
            if (this.Border.IsEmpty || this.Border.IsZero) return this;
            if (newBorder.IsEmpty) throw new ArgumentException(ExceptionMessages.SizeIsEmpty);
            if (newBorder.IsZero) throw new ArgumentException(ExceptionMessages.SizeIsZero);

            return new(this.Value * (newBorder / this.Border), newBorder);
        }
  <# } #>

<# } #>
<# if (HasFlag(RoixStructGeneratorOptions.ArithmeticOperator1)) { #>
        // RoixStructGeneratorOptions.ArithmeticOperator1
        public static <#= Name #> operator +(in <#= Name #> value1, in <#= Name #> value2)
        {
            return new(<#= GetOperate2Value(ArithmeticOperators.Add, "value1", "value2") #>);
        }

        public static <#= Name #> operator -(in <#= Name #> value1, in <#= Name #> value2)
        {
            return new(<#= GetOperate2Value(ArithmeticOperators.Subtract, "value1", "value2") #>);
        }
<# } #>
<# if (HasFlag(RoixStructGeneratorOptions.ArithmeticOperator2)) { #>
        // RoixStructGeneratorOptions.ArithmeticOperator2
        public static <#= Name #> operator *(in <#= Name #> value, double scalar)
        {
            return new(<#= GetOperate1Value(ArithmeticOperators.Multiply, "value", "scalar") #>);
        }

        public static <#= Name #> operator /(in <#= Name #> value, double scalar)
        {
            if (scalar == 0) throw new DivideByZeroException();
            return new(<#= GetOperate1Value(ArithmeticOperators.Divide, "value", "scalar") #>);
        }

        public static <#= Name #> operator *(in <#= Name #> value, in RoixRatioXY ratio)
        {
            return new(<#= GetOperatorRoixAndRatio(ArithmeticOperators.Multiply, "value", "ratio") #>);
        }

        public static <#= Name #> operator /(in <#= Name #> value, in RoixRatioXY ratio)
        {
            if (ratio.IsIncludeZero) throw new DivideByZeroException();
            return new(<#= GetOperatorRoixAndRatio(ArithmeticOperators.Divide, "value", "ratio") #>);
        }

        public static RoixRatioXY operator /(in <#= Name #> value1, in <#= Name #> value2)
        {
            if (value2.IsIncludeZero) throw new DivideByZeroException();
            return new(<#= GetOperate2Value(ArithmeticOperators.Divide, "value1", "value2") #>);
        }
<# } #>

    }
}
