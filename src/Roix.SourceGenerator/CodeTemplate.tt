<#@ template debug="false" hostspecific="false" language="C#" linePragmas="false" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY RoixSourceGenerator. DO NOT CHANGE IT.
// </auto-generated>
#nullable enable
using System;

<# if (!string.IsNullOrEmpty(Namespace)) { #>
namespace <#= Namespace #>
<# } #>
{
    readonly partial struct <#= Name #> : IEquatable<<#= Name #>>, IFormattable
    {
        private readonly SourceValues _values;

<# foreach (var prop in Properties) { #>
        public <#= prop.Type #> <#= prop.Name #> => this._values.<#= prop.Name #>;

<# } #>
<# if (!IsConstructorDeclared) { #>
        public <#= Name #>(<#= GetTypeAndLowerNamesForArgs("{0} {1}") #>)
        {
            this._values = new(<#= GetLowerNames() #>);
<#  if (HasFlag(RoixStructGeneratorOptions.WithBorder)) { #> 
            if (this.Border.IsIncludeNegative) throw new ArgumentException(ExceptionMessages.SizeIsNegative);
<#  } #>
<#  if (HasFlag(RoixStructGeneratorOptions.Validate)) { #> 
            this.Validate(this);
<#  } #>
        }

<# } #>
<# if (HasFlag(RoixStructGeneratorOptions.Validate)) { #>
        // RoixStructGeneratorOptions.Validate
        private partial void Validate(in <#= Name #> value);

<# } #>

        public void Deconstruct(<#= GetTypeAndLowerNames("out {0} {1}") #>) => (<#= GetLowerNames() #>) = (<#= GetNames() #>);

        public bool Equals(<#= Name #> other) => this == other;
        public override bool Equals(object? obj) => (obj is <#= Name #> other) && Equals(other);
        public override int GetHashCode() => HashCode.Combine(<#= GetNames() #>);
        public static bool operator ==(in <#= Name #> left, in <#= Name #> right) => (<#= GetNames("left.{0}") #>) == (<#= GetNames("right.{0}") #>);
        public static bool operator !=(in <#= Name #> left, in <#= Name #> right) => !(left == right);

        public override string ToString() => $"<#= Name #> {{ <#= GetToString() #> }}";
        public string ToString(string? format, IFormatProvider? formatProvider) => $"<#= Name #> {{ <#= GetToStringWithFormat() #> }}";

        public static <#= Name #> Zero { get; } = default;
        public bool IsZero => this == Zero;
        public bool IsNotZero => !this.IsZero;

<# if (Name.Contains("Size") && !Name.Contains("Border")) { #>
        private <#= GetRoixDefaultBuiltInType() #> X => Width;
        private <#= GetRoixDefaultBuiltInType() #> Y => Height;
<# } #>
<# if (HasFlag(RoixStructGeneratorOptions.Rect)) { #>
        // RoixStructGeneratorOptions.Rect
        public <#= GetRoixDefaultBuiltInType() #> X => Location.X;
        public <#= GetRoixDefaultBuiltInType() #> Y => Location.Y;
        public <#= GetRoixDefaultBuiltInType() #> Width => Size.Width;
        public <#= GetRoixDefaultBuiltInType() #> Height => Size.Height;
        public <#= GetRoixDefaultBuiltInType() #> Left => Location.X;
        public <#= GetRoixDefaultBuiltInType() #> Right => Location.X + Size.Width;
        public <#= GetRoixDefaultBuiltInType() #> Top => Location.Y;
        public <#= GetRoixDefaultBuiltInType() #> Bottom => Location.Y + Size.Height;
        public <#= GetRoixPointStructName() #> TopLeft => Location;
        public <#= GetRoixPointStructName() #> TopRight => new(Right, Top);
        public <#= GetRoixPointStructName() #> BottomLeft => new(Left, Bottom);
        public <#= GetRoixPointStructName() #> BottomRight => new(Right, Bottom);

        public bool IsInside(in <#= GetRoixSizeStructName() #> border) => 0 <= Left && Right <= border.Width && 0 <= Top && Bottom <= border.Height;
        public bool IsOutside(in <#= GetRoixSizeStructName() #> border) => !IsInside(border);

        /// <summary>
        /// Roi の左上点を優先して Rect を border サイズに収めます。
        /// Roi の左上点が Border の境界上に乗っている場合は、戻り値の Size が Zero になります。
        /// </summary>
        private <#= Name #> GetClippedRectByPointPriority(in <#= GetRoixSizeStructName() #> border)
        {
            if (IsInside(border)) return this;

            var left = Math.Clamp(this.Left, 0, border.Width);
            var top = Math.Clamp(this.Top, 0, border.Height);

            // 最小側にめり込んで制限された場合は正数になる（その値だけ長さを伸縮する）
            var (deltaLeft, deltaTop) = (left - this.Left, top - this.Top);

            var width = Math.Clamp(this.Width - deltaLeft, 0, border.Width - left);
            var height = Math.Clamp(this.Height - deltaTop, 0, border.Height - top);
            return new(new <#= GetRoixPointStructName() #>(left, top), new <#= GetRoixSizeStructName() #>(width, height));
        }

        /// <summary>
        /// Roi のサイズを優先して Rect を border サイズに収めます。
        /// </summary>
        private <#= Name #> GetClippedRectBySizePriority(in <#= GetRoixSizeStructName() #> border)
        {
            if (IsInside(border)) return this;

            var width = Math.Clamp(this.Width, 0, border.Width);
            var height = Math.Clamp(this.Height, 0, border.Height);
            var left = Math.Clamp(this.Left - GetJutLength(this.Left, this.Right, 0, border.Width), 0, border.Width - width);
            var top = Math.Clamp(this.Top - GetJutLength(this.Top, this.Bottom, 0, border.Height), 0, border.Height - height);
            return new(new <#= GetRoixPointStructName() #>(left, top), new <#= GetRoixSizeStructName() #>(width, height));

            static double GetJutLength(double left, double right, double min, double max)
            {
                // 水平方向の場合、左に食み出てたら負数、右に食み出てたら正数を返します
                if (left < min) return min - left;
                if (max < right) return right - max;
                return 0;
            }
        }

<# } #>
<# if (HasFlag(RoixStructGeneratorOptions.TypeLine)) { #>
        // RoixStructGeneratorOptions.TypeLine
        public <#= GetRoixDefaultBuiltInType() #> X1 => Point1.X;
        public <#= GetRoixDefaultBuiltInType() #> Y1 => Point1.Y;
        public <#= GetRoixDefaultBuiltInType() #> X2 => Point2.X;
        public <#= GetRoixDefaultBuiltInType() #> Y2 => Point2.Y;
        public <#= GetRoixDefaultBuiltInType() #> XMin => Math.Min(Point1.X, Point2.X);
        public <#= GetRoixDefaultBuiltInType() #> XMax => Math.Max(Point1.X, Point2.X);
        public <#= GetRoixDefaultBuiltInType() #> YMin => Math.Min(Point1.Y, Point2.Y);
        public <#= GetRoixDefaultBuiltInType() #> YMax => Math.Max(Point1.Y, Point2.Y);
        public <#= GetRoixDefaultBuiltInType() #> LengthX => Math.Abs(Point2.X - Point1.X);
        public <#= GetRoixDefaultBuiltInType() #> LengthY => Math.Abs(Point2.Y - Point1.Y);

<# } #>
<# if (HasFlag(RoixStructGeneratorOptions.XYPair)) { #>
        // RoixStructGeneratorOptions.XYPair
        public bool IsIncludeZero => (X == 0 || Y == 0);
        public bool IsIncludeNegative => (X < 0 || Y < 0);
        public bool IsInside(in <#= GetRoixSizeStructName() #> border) => (0 <= X && X <= border.Width) && (0 <= Y && Y <= border.Height);
        public bool IsOutside(in <#= GetRoixSizeStructName() #> border) => !IsInside(border);
<# } else if (HasFlag(RoixStructGeneratorOptions.TypeLine)) { #>
        // RoixStructGeneratorOptions.TypeLine
        public bool IsIncludeZero => Point1.IsIncludeZero || Point2.IsIncludeZero;
        public bool IsIncludeNegative => Point1.IsIncludeNegative || Point2.IsIncludeNegative;
        public bool IsInside(in <#= GetRoixSizeStructName() #> border) => Point1.IsInside(border) || Point2.IsInside(border);
        public bool IsOutside(in <#= GetRoixSizeStructName() #> border) => !IsInside(border);
        public bool IsInsideX(<#= GetRoixDefaultBuiltInType() #> x) => (XMin <= x && x <= XMax);
        public bool IsInsideY(<#= GetRoixDefaultBuiltInType() #> y) => (YMin <= y && y <= YMax);
        public bool IsOutsideX(<#= GetRoixDefaultBuiltInType() #> x) => !IsInsideX(x);
        public bool IsOutsideY(<#= GetRoixDefaultBuiltInType() #> y) => !IsInsideY(y);
<# } #>

<# if (HasFlag(RoixStructGeneratorOptions.WithBorder)) { #>
        // RoixStructGeneratorOptions.WithBorder
        public bool IsInsideBorder => this.Value.IsInside(this.Border);
        public bool IsOutsideBorder => !this.IsInsideBorder;

        public <#= Name #> ConvertToNewBorder(in <#= GetRoixSizeStructName() #> newBorder)
        {
            if (this.Border.IsEmpty || this.Border.IsZero) return this;
            if (newBorder.IsEmpty) throw new ArgumentException(ExceptionMessages.SizeIsEmpty);
            if (newBorder.IsZero) throw new ArgumentException(ExceptionMessages.SizeIsZero);

            return new(this.Value * (newBorder / this.Border), newBorder);
        }
<#  if (HasFlag(RoixStructGeneratorOptions.TypeInt)) { #>
        public <#= GetRoixNameWithoutInt() #> ConvertToNewBorder(in RoixSize newBorder)
        {
            if (this.Border.IsEmpty || this.Border.IsZero) return this;
            if (newBorder.IsEmpty) throw new ArgumentException(ExceptionMessages.SizeIsEmpty);
            if (newBorder.IsZero) throw new ArgumentException(ExceptionMessages.SizeIsZero);

            return new(this.Value * (newBorder / this.Border), newBorder);
        }
<#  } #>

<# } #>
<# if (!HasFlag(RoixStructGeneratorOptions.TypeInt)) { #>
<#  if (HasFlag(RoixStructGeneratorOptions.XYPair)) { #>
<#  /* ↓is not TypeInt && XYPair↓ */ #>
        public <#= GetRoixNameWithInt() #> ToRoixInt(RoundingMode roundingX, RoundingMode roundingY)
        {
            return new(X.ToInt(roundingX), Y.ToInt(roundingY));
        }
        public <#= GetRoixNameWithInt() #> ToRoixInt(RoundingMode rounding = RoundingMode.Floor)
        {
            return ToRoixInt(rounding, rounding);
        }
<#  } else if (HasFlag(RoixStructGeneratorOptions.Rect) || HasFlag(RoixStructGeneratorOptions.TypeLine) || HasFlag(RoixStructGeneratorOptions.WithBorder)) { #>
<#  /* ↓is not TypeInt && (is not XYPair)↓ */ #>
        public <#= GetRoixNameWithInt() #> ToRoixInt(RoundingMode roundingX, RoundingMode roundingY)
        {
            return new(<#= GetNames("{0}.ToRoixInt(roundingX, roundingY)") #>);
        }
        public <#= GetRoixNameWithInt() #> ToRoixInt(RoundingMode rounding = RoundingMode.Floor)
        {
            return ToRoixInt(rounding, rounding);
        }
<#  } #>
<# } #>

<# if (HasFlag(RoixStructGeneratorOptions.HasParent)) { #>
        // RoixStructGeneratorOptions.HasParent
        public <#= GetRoixBorderName() #> ToRoixBorder(in <#= GetRoixSizeStructName() #> size)
        {
            if (size.IsIncludeNegative) throw new ArgumentException(ExceptionMessages.SizeIsNegative);
            return new(this, size);
        }

        public <#= GetRoixBorderName() #> ToRoixBorder(<#= GetRoixDefaultBuiltInType() #> width, <#= GetRoixDefaultBuiltInType() #> height)
        {
            return this.ToRoixBorder(new <#= GetRoixSizeStructName() #>(width, height));
        }
<# } #>

<# /* ↓ArithmeticOperator1↓ */ #>
<# if (HasFlag(RoixStructGeneratorOptions.ArithmeticOperator1)) { #>
        // RoixStructGeneratorOptions.ArithmeticOperator1
        public static <#= Name #> operator +(in <#= Name #> value1, in <#= Name #> value2)
        {
<#  if (HasFlag(RoixStructGeneratorOptions.HasEmpty)) { #>
            if (value1.IsEmpty || value2.IsEmpty) return Empty;
<#  } #>
            return new(<#= GetOperate2Value(ArithmeticOperators.Add, "value1", "value2") #>);
        }

        public static <#= Name #> operator -(in <#= Name #> value1, in <#= Name #> value2)
        {
<#  if (HasFlag(RoixStructGeneratorOptions.HasEmpty)) { #>
            if (value1.IsEmpty || value2.IsEmpty) return Empty;
<#  } #>
            return new(<#= GetOperate2Value(ArithmeticOperators.Subtract, "value1", "value2") #>);
        }
<# } #>
<# /* ↑ArithmeticOperator1↑ */ #>

<# /* ↓ArithmeticOperator2↓ */ #>
<# if (HasFlag(RoixStructGeneratorOptions.ArithmeticOperator2)) { #>
        // RoixStructGeneratorOptions.ArithmeticOperator2
        public static <#= Name #> operator *(in <#= Name #> value, double scalar)
        {
<#  if (HasFlag(RoixStructGeneratorOptions.HasEmpty)) { #>
            if (value.IsEmpty) return Empty;
<#  } #>
            return new(<#= GetOperate1Value(ArithmeticOperators.Multiply, "value", "scalar") #>);
        }

        public static <#= Name #> operator /(in <#= Name #> value, double scalar)
        {
<#  if (HasFlag(RoixStructGeneratorOptions.HasEmpty)) { #>
            if (value.IsEmpty) return Empty;
<#  } #>
            if (scalar == 0) throw new DivideByZeroException();
            return value * (1d / scalar);
        }

<#  /* ↓ArithmeticOperator2 && XYPair↓ */ #>
<#  if (HasFlag(RoixStructGeneratorOptions.XYPair)) { #>
        public static <#= Name #> operator *(in <#= Name #> value, in RoixRatioXY ratio)
        {
<#   if (HasFlag(RoixStructGeneratorOptions.HasEmpty)) { #>
            if (value.IsEmpty) return Empty;
<#   } #>
            return new(<#= GetOperatorRoixAndRatioXY(ArithmeticOperators.Multiply, "value", "ratio") #>);
        }

        public static <#= Name #> operator /(in <#= Name #> value, in RoixRatioXY ratio)
        {
<#   if (HasFlag(RoixStructGeneratorOptions.HasEmpty)) { #>
            if (value.IsEmpty) return Empty;
<#   } #>
            if (ratio.IsIncludeZero) throw new DivideByZeroException();
            return new(<#= GetOperatorRoixAndRatioXY(ArithmeticOperators.Divide, "value", "ratio") #>);
        }

        public static RoixRatioXY operator /(in <#= Name #> value1, in <#= Name #> value2)
        {
<#   if (HasFlag(RoixStructGeneratorOptions.HasEmpty)) { #>
            if (value.IsEmpty) return Empty;
<#   } #>
            if (value2.IsIncludeZero) throw new DivideByZeroException();
            return new(<#= GetOperate2Value(ArithmeticOperators.Divide, "value1", "value2") #>);
        }
<#  /* ↓ArithmeticOperator2 && (is not XYPair)↓ */ #>
<#  } else { #>
        public static <#= Name #> operator *(in <#= Name #> value, in RoixRatioXY ratio)
        {
<#   if (HasFlag(RoixStructGeneratorOptions.HasEmpty)) { #>
            if (value.IsEmpty) return Empty;
<#   } #>
            return new(<#= GetOperatorRoixAndRatio(ArithmeticOperators.Multiply, "value", "ratio") #>);
        }

        public static <#= Name #> operator /(in <#= Name #> value, in RoixRatioXY ratio)
        {
<#   if (HasFlag(RoixStructGeneratorOptions.HasEmpty)) { #>
            if (value.IsEmpty) return Empty;
<#   } #>
            if (ratio.IsIncludeZero) throw new DivideByZeroException();
            return new(<#= GetOperatorRoixAndRatio(ArithmeticOperators.Divide, "value", "ratio") #>);
        }
<#  } #>
<# } #>
<# /* ↑ArithmeticOperator2↑ */ #>

<# if (Name.Contains("Point") && !Name.Contains("Border")) { #>
        /// <summary>2点の距離を計算します</summary>
        public double GetDistance(in <#= Name #> point)
        {
            var x = (double)this.X - point.X;
            var y = (double)this.Y - point.Y;
            return Math.Sqrt(x * x + y * y);
        }
<# } else if (Name.Contains("Line") && !Name.Contains("Border")) { #>
        /// <summary>2点の距離を計算します</summary>
        public double GetDistance() => Point1.GetDistance(Point2);
<# } #>

    }
}
